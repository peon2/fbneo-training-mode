assert(rb,"Run fbneo-training-mode.lua")

-- This file is meant to be run by scrolling-input-display.lua
-- user: Do not edit this file.

local recordpath = "framedump" --(relative to resourcepath)

--[[
print("Scrolling input display Lua script, " .. version)
print("Press " .. (input.registerhotkey and "Lua hotkey 1" or playerswitch) .. " to toggle players.")
print("Press " .. (input.registerhotkey and "Lua hotkey 2" or clearkey) .. " to clear the screen.")
print("Press " .. (input.registerhotkey and "Lua hotkey 3" or sizekey) .. " to resize the icons.")
print("Press " .. (input.registerhotkey and "Lua hotkey 4" or scalekey) .. " to toggle icon stretching.")
print("Press " .. (input.registerhotkey and "Lua hotkey 5" or recordkey) .. " to start/stop recording to '" .. recordpath .. "' folder")
print()
]]--

require "gd"
local minimum_tile_size, maximum_tile_size = 4, 16
local icon_size, image_icon_size = inputs.properties.scrollinginput.iconsize
local thisframe, lastframe, module, keyset, changed = {}, {}
local margin, rescale_icons, recording, display, start, effective_width = {}, true, false
local draw = { [1] = true, [2] = true }
local inp  = { [1] =   {}, [2] =   {} }
local idle = { [1] =    0, [2] =    0 }

for m, scheme in ipairs(gamekeys) do --Detect what set to use.
	if string.find(iconfile:lower(), scheme.set[1]:lower()) then
		module = scheme
		for k, emu in pairs(scheme.set) do --Detect what emulator this is.
			if k > 1 and emu then
				keyset = k
				break
			end
		end
		break
	end
end
if not module then error("There's no module available for " .. iconfile, 0) end
if not keyset then error("The '" .. module.set[1] .. "' module isn't prepared for this emulator.", 0) end

--hardcoded check corrects button mapping discrepancy between Tekken 1/2 and Tekken3/TTT
if mame and emu.sourcename() == "namcos11.c" then
	module[11][keyset],module[12][keyset],module[13][keyset] = nil,"Button 3","Button 4"
end

resourcepath = resourcepath .. "/"
recordpath = recordpath .. "/"
emu = emu or gens
----------------------------------------------------------------------------------------------------
-- image-string conversion functions

local function hexdump_to_string(hexdump)
	local str = ""
	for n = 1, hexdump:len(), 2 do
		str = str .. string.char("0x" .. hexdump:sub(n,n+1))
	end
	return str
end

local function string_to_hexdump(str)
	local hexdump = ""
	for n = 1, str:len() do
		hexdump = hexdump .. string.format("%02X",str:sub(n,n):byte())
	end
	return hexdump
end
--example usage:
--local image = gd.createFromPng("image.png")
--local str = image:pngStr()
--local hexdump = string_to_hexdump(str)

local blank_img_hexdump = 
"89504E470D0A1A0A0000000D49484452000000400000002001030000009853ECC700000003504C5445000000A77A3DDA00" ..
"00000174524E530040E6D8660000000D49444154189563601805F8000001200001BFC1B1A80000000049454E44AE426082"
local blank_img_string = hexdump_to_string(blank_img_hexdump)

----------------------------------------------------------------------------------------------------
-- display functions

local function text(x, y, row)
	gui.text(x, y, module[row][1])
end

local function image(x, y, row)
	gui.gdoverlay(x, y, module[row].img)
end

display = image
if not io.open(resourcepath .. iconfile, "rb") then
	print("Icon file " .. iconfile .. " not found.")
	print("Falling back on text mode.")
	display = text
end

local function readimages()
	local scaled_width = icon_size
	if rescale_icons and emu.screenwidth and emu.screenheight then
		scaled_width = icon_size * emu.screenwidth()/emu.screenheight() / (4/3)
	end
	if display == image then
		sourceimg = gd.createFromPng(resourcepath .. iconfile)
		image_icon_size = sourceimg:sizeX()/2;
		for n, key in ipairs(module) do
			key.img = gd.createFromPngStr(blank_img_string)
			gd.copyResampled(key.img, sourceimg, 0, 0, 0,(n-1)*image_icon_size, scaled_width, icon_size, image_icon_size, image_icon_size)
			key.img = key.img:gdStr()
		end
	end
	effective_width = scaled_width
end
readimages()

----------------------------------------------------------------------------------------------------
-- update functions

local function filterinput(p, frame)
	for pressed, state in pairs(joypad.getdown(p)) do --Check current controller state >
		for row, name in pairs(module) do               --but ignore non-gameplay buttons.
			if pressed == name[keyset]
		--Arcade does not distinguish joypads, so inputs must be filtered by "P1" and "P2".
			or pressed == "P" .. p .. " " .. tostring(name[keyset])
		--MAME also has unusual names for the start buttons.
			or pressed == p .. (p == 1 and " Player " or " Players ") .. tostring(name[keyset]) then
				frame[row] = state
				break
			end
		end
	end
end

local function compositeinput(frame)          --Convert individual directions to diagonals.
	for _,dir in pairs({ {1,3,5}, {2,3,6}, {1,4,7}, {2,4,8} }) do --ul, ur, dl, dr
		if frame[dir[1]] and frame[dir[2]] then
			frame[dir[1]], frame[dir[2]], frame[dir[3]] = nil, nil, true
		end
	end
end

local function detectchanges(lastframe, thisframe)
	changed = false
	for key, state in pairs(thisframe) do       --If a key is pressed >
		if lastframe and not lastframe[key] then  --that wasn't pressed last frame >
			changed = true                          --then changes were made.
			break
		end
	end
end

local function updaterecords(player, frame, input)
	if changed then                         --If changes were made >
		if idle[player] < timeout then        --and the player hasn't been idle too long >
			for record = buffersize, 2, -1 do
				input[record] = input[record-1]   --then shift every old record by 1 >
			end
		else
			for record = buffersize, 2, -1 do
				input[record] = nil               --otherwise wipe out the old records.
			end
		end
		idle[player] = 0                      --Reset the idle count >
		input[1] = {}                         --and set current input as record 1 >
		local index = 1
		for row, name in ipairs(module) do    --but the order must not deviate from gamekeys.
			for key, state in pairs(frame) do
				if key == row then
					input[1][index] = row
					index = index+1
					break
				end
			end
		end
	else
		idle[player] = idle[player]+1         --Increment the idle count if nothing changed.
	end
end

----------------------------------------------------------------------------------------------------
-- savestate functions

--[[if savestate.registersave and savestate.registerload then --registersave/registerload are unavailable in some emus
	savestate.registersave(function(slot)
		return draw, inp, idle
	end)

	savestate.registerload(function(slot)
		draw, inp, idle = savestate.loadscriptdata(slot)
		if type(draw) ~= "table" then draw = { [1] = true, [2] = true } end
		if type(inp)  ~= "table" then inp  = { [1] =   {}, [2] =   {} } end
		if type(idle) ~= "table" then idle = { [1] =    0, [2] =    0 } end
	end)
end
--]]
----------------------------------------------------------------------------------------------------
-- hotkey functions

local togglestate = inputs.properties.scrollinginput.state

function togglescrollinginputsplayer()
	if togglestate==1 then
		draw[1] = true
		draw[2] = false
	elseif togglestate==2 then
		draw[1] = false
		draw[2] = true
	elseif togglestate==3 then
		draw[1] = true
		draw[2] = true
	elseif togglestate==4 then
		draw[1] = false
		draw[2] = false
	end
end

togglescrollinginputsplayer()

--[[

local function clear()
	inp = { [1] = {}, [2] = {} }
	emu.message("Cleared screen.")
end

local function resize()
	if icon_size < maximum_tile_size then
		icon_size = icon_size + minimum_tile_size/4
	else
		icon_size = minimum_tile_size
	end
	emu.message("Icon size: " .. icon_size)
	readimages()
end

local function togglescaling()
	rescale_icons = not rescale_icons
	if emu.screenwidth and emu.screenheight then
		emu.message("Icon stretching " .. (rescale_icons and "on." or "off."))
		readimages()
	else
		emu.message("This emulator does not support icon scaling.")
	end
end

local function togglerecording()
	recording = not recording
	if recording then
		start = movie.framecount()
		print("Started recording.")
	else
		local stop = movie.framecount()
		print("Stopped recording. (" .. stop - start .. " frames)")
		if stop > start then
			print(string.format("'moviedump-%06d.png' to 'moviedump-%06d.png'", start, stop-1))
		end
		print()
		start = nil
	end
end
--]]

--[[
if input.registerhotkey then
	input.registerhotkey(1, function()
		toggleplayer()
	end)
	
	input.registerhotkey(2, function()
		clear()
	end)

	input.registerhotkey(3, function()
		resize()
	end)

	input.registerhotkey(4, function()
		togglescaling()
	end)

	input.registerhotkey(5, function()
		togglerecording()
	end)
	
end
]]--

--[[
local oldswitch, oldclearkey, oldsizekey, oldscalekey, oldrecordkey
emu.registerbefore( function()
	if not input.registerhotkey then --use input.get if registerhotkey is unavailable
		local nowswitch = input.get()[playerswitch]
		if nowswitch and not oldswitch then
				toggleplayer()
		end
		oldswitch = nowswitch

		local nowclearkey = input.get()[clearkey]
		if nowclearkey and not oldclearkey then
			clear()
		end
		oldclearkey = nowclearkey

		local nowsizekey = input.get()[sizekey]
		if nowsizekey and not oldsizekey then
			resize()
		end
		oldsizekey = nowsizekey

		local nowscalekey = input.get()[scalekey]
		if nowscalekey and not oldscalekey then
			togglescaling()
		end
		oldscalekey = nowscalekey

		local nowrecordkey = input.get()[recordkey]
		if nowrecordkey and not oldrecordkey then
			togglerecording()
		end
		oldrecordkey = nowrecordkey
	end
end)
--]]

function scrollingInputReg()
	gui.text(0,0,"")
	for player = 1, 2 do
		if draw[player] then
			for line in pairs(inp[player]) do
				for index,row in pairs(inp[player][line]) do
					display(margin[player] + (index-1)*effective_width, margin[3] + (line-1)*icon_size, row)
				end
			end
		end
	end
end

function scrollingInputRegAfter()
	margin[1] = margin_left*effective_width
	margin[2] = (emu.screenwidth and emu.screenwidth() or screenwidth) - margin_right*effective_width
	margin[3] = margin_top*icon_size
	for player = 1, 2 do
		thisframe = {}
		filterinput(player, thisframe)
		compositeinput(thisframe)
		detectchanges(lastframe[player], thisframe)
		updaterecords(player, thisframe, inp[player])
		lastframe[player] = thisframe
	end
	if recording then
		gd.createFromGdStr(gui.gdscreenshot()):png(resourcepath .. recordpath .. string.format("moviedump-%06d.png", movie.framecount()))
	end
end

function scrollingInputReload()
	icon_size = inputs.properties.scrollinginput.iconsize
	togglestate = inputs.properties.scrollinginput.state
	readimages()
	togglescrollinginputsplayer()
end
